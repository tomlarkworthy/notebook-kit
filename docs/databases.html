<!doctype html>
<notebook theme="slate">
  <title>Observable Notebooks Database connectors</title>
  <script id="1" type="text/markdown">
    # Observable Notebooks<br> <span style="color: var(--theme-foreground-faint);">Database connectors</span>

    <link rel="stylesheet" href="./style.css">
  </script>
  <script id="17" type="text/markdown">
    **what are database connectors?** database connectors allow you to query SQL databases from a notebook. they power SQL cells, as well as the `DatabaseClient` JavaScript API.
  </script>
  <script id="18" type="text/markdown">
    **why would i want to connect to a database?** business data is often stored in a database or data warehouse. if you want to do business intelligence, exploratory data analysis, or simply make a chart or dashboard, you'll likely need data from a database.
  </script>
  <script id="33" type="text/markdown">
    **why do i need a database connector to connect to a database?** databases typically need specialized software (database drivers) to connect and execute queries. databases don't typically expose an HTTP API, so browsers can't talk to them directly.
  </script>
  <script id="34" type="text/markdown">
    **do i really need a database connector?** no, you don't need a database connector to work with data from a database in a notebook: you can manually extract data from your database, store it in a file, and use the `FileAttachment` JavaScript API to load it into a notebook.
  </script>
  <script id="14" type="text/markdown">
    **so why do i need a database connector?** database connectors make it much more convenient to query data, and to keep data up-to-date, because you don't have to switch tools and juggle files --- you can query right from a notebook! you can even query databases interactively, for example passing in dynamic parameters that are specified via a drop-down, slider, or text input.
  </script>
  <script id="50" type="text/markdown">
    **are query results saved?** yes. to improve performance (data that loads instantly!), to ensure that viewers see the same data that you do, and to enable point-in-time analysis (not just live dashboards), query results are automatically saved to a `.observable/cache` directory on your local file system alongside your notebooks.
  </script>
  <script id="21" type="text/markdown">
    **that's a big difference from notebooks 1.0!** yes. database connectors in notebooks 1.0 only supported live (unsaved) queries. this often meant slow notebooks and different users seeing different data. and it made point-in-time analysis tedious because query results must be manually captured as file attachments. and there was no way to share a notebook without giving access to the database. automatic query caching isn't just about performance; it unlocks more robust and secure ways of working and sharing analysis.
  </script>
  <script id="20" type="text/markdown">
    **if query results are saved, how do i update them?** If you are using Observable Desktop, you can re-run a SQL cell by clicking the **Play** button or by hitting <span style="font-family: var(--sans-serif);">**shift-return**</span>, or click on the query age in the top-right corner. If you are using Observable Notebook Kit, you can delete the corresponding file from the `.observable/cache` directory before building your notebook. With Notebook Kit, you can use continuous deployment (such as GitHub Actions) to update your data automatically.
  </script>
  <script id="28" type="text/markdown">
    **how do i configure my database?** if you are using DuckDB or PostgreSQL with the default settings, no configuration is required; simply specify `duckdb` or `postgres` as your database in the SQL cell. note that you must save your notebook before issuing any queries (since this determines what databases are available to the notebook, and where query results are saved). you can configure your databases by editing the `.observable/databases.json` file alongside your notebook. for example, if your notebooks are stored in `docs`, then a notebook `docs/example.html` can access any database configured in `docs/.observable/databases.json`.  in the future, Observable Desktop will provide a built-in UI for configuring databases.
  </script>
  <script id="15" type="text/markdown">
    **what databases are supported?** currently DuckDB, Snowflake, PostgreSQL, and any database that "speaks" PostgreSQL, such as ClickHouse, Amazon Redshift, and Google Cloud SQL. we plan on adding more data connectors soon. our data connectors are [open-source](https://github.com/observablehq/notebook-kit/tree/main/src/databases) and we welcome contributions of additional database drivers! we recommend OLAP databases because fast _ad hoc_ queries greatly accelerate analysis.
  </script>
  <script id="35" type="text/markdown">
    **how do i query my database?** insert a new cell, say by clicking the plus button between cells. convert it to a SQL cell using down arrow, or by hitting <span style="font-family: var(--sans-serif);">⌘4</span>. by default, SQL cells query the `duckdb` database. to query a different database, edit the **database** field in the toolbar at the top of the SQL cell. click the ↩︎ or hit <span style="font-family: var(--sans-serif);">return</span> after you have entered the database name. then focus the SQL cell, edit your query, and hit <span style="font-family: var(--sans-serif);">shift-return</span> to run it.
  </script>
  <script id="36" type="application/sql" pinned="" database="duckdb">
    SELECT 1 + 2
  </script>
  <script id="40" type="text/markdown">
    A SQL cell typically contains a single `SELECT` statement.
  </script>
  <script id="24" type="text/markdown">
    **how are query results displayed?** SQL cells currently use Observable Inputs (`Inputs.table`) to display query results. Thanks to virtual rendering, this allows you to scroll through large result sets performantly. Additionally, you can sort columns by clicking on column headers.
  </script>
  <script id="41" type="text/markdown">
    **can i hide the table?** yes. use <span style="font-family: var(--sans-serif);">command-,</span> (or <span style="font-family: var(--sans-serif);">esc</span> <span style="font-family: var(--sans-serif);">,</span>) to hide the table display. you can also mark the cell as hidden from the cell menu (where it says `sql` in the top-right of the cell) and the edit menu.
  </script>
  <script id="26" type="text/markdown">
    **i would like better tables.** us too! we're only using `Inputs.table` temporarily. we plan on replacing them with summary tables, similar to the summary tables in [Observable Notebooks 1.0](https://observablehq.com/documentation/cells/sql) and in [Observable Canvases](https://observablehq.com/platform/canvases). these future summary tables will provide a more comprehensive visual overview of tabular data, and allow much more powerful interactive filtering. note that you can already filter tables using the checkboxes in the first column: only checked rows will be visible to downstream cells. interactive filters are not persistent: filters are reset whenever you re-run the query or reload the notebook.
  </script>
  <script id="23" type="text/markdown">
    **how do i access query results from javascript?** by defining an **output** for a SQL cell, you expose a top-level variable that allows other cells to access the query results. these query results are currently exposed in the array-of-objects format. however, in the future, we will likely adopt the Apache Arrow table instead for performance and scalability.
  </script>
  <script id="37" type="application/sql" pinned="" database="duckdb" output="three">
    SELECT 1 AS foo
    UNION ALL SELECT 2
    UNION ALL SELECT 3
  </script>
  <script id="39" type="text/markdown">
    Here is the result:
  </script>
  <script id="38" type="module" pinned="">
    three
  </script>
  <script id="49" type="text/markdown">
    **show me a more interesting example.** okay, how about a quick look at a dataset of 20M taxi rides? here's how you can count the number of trips per hour. (data via [NYC Taxi & Limousine Commission](https://www.nyc.gov/site/tlc/about/tlc-trip-record-data.page), june 2025)
  </script>
  <script id="3" type="application/sql" pinned="" database="duckdb" output="trips">
    SELECT
      DATE_TRUNC('hour', pickup_datetime) AS date,
      COUNT(*) AS count
    FROM read_parquet("fhvhv_tripdata_2025-06.parquet")
    GROUP BY 1
    ORDER BY 1 DESC
  </script>
  <script id="5" type="module" pinned="">
    Plot.plot({
      y: {grid: true},
      marks: [
        Plot.axisY({tickFormat: (d) => d / 1000, label: "Trips per hour (thousands)"}),
        Plot.areaY(trips, {x: "date", y: "count", curve: "step", fillOpacity: 0.2}),
        Plot.ruleY([0]),
        Plot.lineY(trips, {x: "date", y: "count", curve: "step", tip: true}),
      ]
    })
  </script>
  <script id="58" type="text/markdown">
    or, by hour of day, and day of week?
  </script>
  <script id="55" type="application/sql" pinned="" database="duckdb" output="trips_heatmap">
    SELECT
      EXTRACT(dow FROM pickup_datetime) AS dow,
      EXTRACT(hour FROM pickup_datetime) AS hour,
      COUNT(*) AS count
    FROM read_parquet("fhvhv_tripdata_2025-06.parquet")
    GROUP BY 1, 2
    ORDER BY 1, 2
  </script>
  <script id="56" type="module" pinned="">
    Plot.plot({
      padding: 0,
      label: null,
      y: {tickFormat: Plot.formatWeekday("en")},
      color: {scheme: "ylorrd", label: "Number of trips", zero: true, legend: true},
      marks: [Plot.rect(trips_heatmap, {x: "hour", y: "dow", fill: "count", inset: 0.5, tip: true})]
    })
  </script>
  <script id="16" type="text/markdown">
    **my data is sensitive; what happens to my data when i run a query?** Database connectors run locally on your computer, meaning that your data stays private, and you can access database on your local machine or local network without going through Observable servers. If you are using DuckDB, you can read local files in the same directory as your notebook.
  </script>
  <script id="43" type="text/markdown">
    **my database credentials are sensitive! how do i keep them secure?** The `databases.json` file typically contains credentials and passwords to access sensitive data, and thus should not be committed to source control. We recommend excluding the `.observable` directory by adding it to your `.gitignore`, like so:

    ```
    .observable
    ```

    The `.observable` folder also contains the query results cache (`.observable/cache`) and the built site (`.observable/dist`) into source control, which are you unlikely to want in source control. But if you do want to commit cached query results to source control, you can.
  </script>
  <script id="44" type="text/markdown">
    **some of my notebooks need to talk to different databases, and some of my notebooks are untrusted; what do i do?** use different folders to separate notebooks with different levels of trust, and to configure different databases. any notebook in the same folder will have access to the same files and databases, so if you configure a sensitive database, you should only put trusted notebooks in that folder. notebooks cannot access file or databases from outside of the folder they live in. don't mix trusted and untrusted notebooks in the same folder.
  </script>
  <script id="22" type="text/markdown">
    **does sharing my notebook require giving readers access to my database?** no. notebook kit builds a static site, so everything is self-contained, including the query results. queried data can therefore be shared along with your notebook, meaning that readers do not need access to your database. note that this also means that shared notebooks cannot use dynamic queries since queries must be declared statically to be "baked" at build time. however, you can use client-side data transformations and filtering, and even a client-side database such as `DuckDBClient`, to power interactivity on the client.
  </script>
  <script id="29" type="text/markdown">
    **how do i issue dynamic queries?** you can use `$\{…}` to interpolate javascript expressions into queries in SQL cells. you can also use the `DatabaseClient` JavaScript API to issue queries dynamically. however, note dynamic queries cannot be baked at build time, so dynamic queries are only suitable for use while editing notebooks within Observable Desktop, while previewing with Notebook Kit, or when using a client-side database such as `DuckDBClient` (DuckDB-Wasm).
  </script>
  <script id="42" type="text/markdown">
    **what about custom database clients and DuckDB-Wasm?** if you specify the database using `var:`, for example as `var:db` to refer to the `db` variable, you can provide a custom database client that runs in the browser. this is most often used with `DuckDBClient` (DuckDB-Wasm), but you can provide any `DatabaseClient` implementation that exposes a `sql` tagged template literal. for custom database clients, query results are not saved.
  </script>
  <script id="10" type="text/markdown">
    **how do i use databases with Notebook Kit?** database drivers come bundled with Observable Desktop, but are not installed by default with Notebook Kit; database drivers are marked as optional peer dependencies, and you must install them yourself.

    To install the DuckDB driver:

    ```sh
    npm add @duckdb/node-api
    ```

    To install the Postgres driver:

    ```sh
    npm add postgres
    ```

    To install the Snowflake driver:

    ```sh
    npm add snowflake-sdk
    ```
  </script>
  <script id="46" type="text/markdown">
    **what is the format of the `databases.json` file?** The `databases.json` file can configure multiple databases. Each database must have a unique name, the database type, and corresponding configuration options. Database names must consist exclusively of letters, numbers, and hyphens (as a regex, `/^[\w-]+$/`); spaces and other characters are not allowed. For example, here is a `databases.json` file that configures a `demo` Snowflake database:

    ```json
    {
      "demo": {
        "type": "snowflake",
        "account": "tk421.us-east-1.aws",
        "database": "demo",
        "role": "public",
        "schema": "public",
        "username": "demo",
        "warehouse": "demo",
        "password": "opensesame"
      }
    }
    ```
  </script>
  <script id="53" type="text/markdown">
    **how do i configure duckdb?** the following options are supported:

    ```ts
    type DuckDBConfig = {
      type: "duckdb";
      path?: string;
      options?: {[key: string]: string};
    }
    ```

    The **path** option stores the relative path to the DuckDB (`.duckdb`) database file; if not specified, the database will be in-memory (`:memory:`). The **options** object contains any [DuckDB configuration options](https://duckdb.org/docs/stable/configuration/overview.html).
  </script>
  <script id="52" type="text/markdown">
    **how do i configure postgres?** the following options are supported:

    ```ts
     type PostgresConfig = {
      type: "postgres";
      host?: string;
      port?: string | number;
      username?: string;
      password?: string;
      database?: string;
      ssl?: boolean;
    }
    ```

    if you do not specify any options, the postgres database must be running on localhost with the default user and database. See the [Postgres driver documentation](https://github.com/porsager/postgres/blob/master/README.md#connection-details) for details.
  </script>
  <script id="51" type="text/markdown">
    **how do i configure snowflake?** the following options are supported:

    ```ts
    type SnowflakeConfig = {
      type: "snowflake";
      account: string;
      database?: string;
      role?: string;
      schema?: string;
      username?: string;
      warehouse?: string;
      password?: string;
    }
    ```

    See the [Snowflake Node.js driver documentation](https://docs.snowflake.com/en/developer-guide/node-js/nodejs-driver-authenticate) for details.
  </script>
</notebook>
